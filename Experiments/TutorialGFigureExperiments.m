%
%  Tutorial on the usage of GFigure. Just read this file sequentially from
%  the beginning or jump to the section that is most relevant for you.
%

classdef TutorialGFigureExperiments < ExperimentFunctionSet
		
	methods
			
		%% 0. Introduction ================================================
		% This experiment file gradually introduces the reader to the usage
		% of GFigure. Feel free to experiment with it. For improved
		% readability, you may fold the functions in this class; see MATLAB
		% documentation if necessary. 
		%
		% Please ensure that your variable <experimentFile> in gsim.m is 
		% set to TutorialFfigureExperiments by using the following line:
		%
		% >> experimentFile = TutorialFfigureExperiments;
		%				
		%% 1. How to avoid using GFigure =================================
		% Unconventionally for a tutorial of this kind, this one starts by
		% explaining how to avoid using GFigure yet preserving some of its
		% benefits. The idea is to first plot a figure through
		% the conventional way in MATLAB and then invoking 
		%
		% >>   F = GFigure.captureCurrentFigure()
		%
		% as illustrated in the following example:
		%
		function F = experiment_1001(obj,niter)
		
			v_x = -10:0.01:10;
			v_y = v_x.^2;
			plot(v_x,v_y)
			
			F = GFigure.captureCurrentFigure();
			
		end	
		% You can execute this using
		% 
		% >> gsim(0,1001)
		%
		% The method GFigure.captureCurrentFigure() creates an GFigure
		% using your current axis. The created GFigure is displayed as
		% figure number 1001 in a new window to confirm that everything
		% went correctly. That GFigure is now stored in your file system;
		% if you want to plot the saved GFigure, you just need to type
		%
		% >> gsim(1,1001)
		%
		% Note that the code inside the above function experiment_1001()
		% will not be executed again. The created GFigure is stored in the
		% file Experiments/TutorialFfigureExperiments_data/...
		% TutorialFfigureExperiments_1001.mat. 
		%
		% If your experiment produces multiple figures you just need to
		% create a vector of GFigures as shown by the next example:
		%
		function F = experiment_1002(obj,niter)
		
			figure(1)
			v_x = -10:0.01:10;
			v_y = v_x.^2;
			plot(v_x,v_y)			
			F(1) = GFigure.captureCurrentFigure();
			
			figure(2)
			v_x = -5:0.01:5;
			v_y = v_x.^3;
			plot(v_x,v_y)			
			F(2) = GFigure.captureCurrentFigure();
			
		end	
		% Again, you can run this experiment by typing
		%
		% >> gsim(0,1002)
		%
		% and solely plot its results using
		%
		% >> gsim(1,1002)
		%
		%% 2. How to actually use GFigure ================================
		% To fully benefit from the potential of GFigure, one needs to
		% create an GFigure "object". Do not worry if you do not know
		% object-oriented programming (OOP), since it is not necessary to
		% use GFigure.  
		% 
		% It suffices to know that experiment functions, denoted as
		% experiment_XXXX(), must return an GFigure object (or vector of
		% GFigure objects as in experiment_1002) and that such
		% an object can be created just by typing 
		%
		% >> F = GFigure();
		%
		% Objects are essentially data structures with multiple fields for
		% storing data or functions, each with a name that identifies it.
		% For the recently created GFigure object, examples of these
		% fields, called "properties" in the OOP terminology, are F.m_X,
		% F.ch_title, and F.c_legend. The list and description of all the
		% properties of a GFigure object are provided in the file
		% Execution/GFigure.m.
		% 
		% The following experiment is equivalent to experiment 1001, but
		% now we actually create an GFigure object by specifying its
		% fields. 
		function F = experiment_2001(obj,niter)

			v_x = -10:0.01:10;
			v_y = v_x.^3;
			
			F = GFigure();
			F.m_X = v_x;
			F.m_Y = v_y;

		end	
		% Whereas in experiment_1001 we create an GFigure by giving it an
		% already constructing figure through the method
		% GFigure.captureCurrentFigure(), in experiment_2001 we create an
		% GFigure and indicate how it can plot the figure itself. It is as
		% if GFigure "understands" the figure in experiment_2001 but not
		% in experiment_1001. As a consequence, there are several features
		% of GFigure that cannot be exploited when following the approach
		% in experiment_1001. 
		%
		% For example, note that the lines in the figure generated by
		% experiment_2001 are are thicker than those in the figure
		% generated by experiment_1001. There is also a grid that was not
		% before. Features of this kind are highly desirable when exporting
		% a figure to use it on a paper. 
		% 
		% The notation in experiment_2001 can be sortened as follows:
		function F = experiment_2002(obj,niter)

			v_x = -10:0.01:10;
			v_y = v_x.^3;			
			F = GFigure('m_X',v_x,'m_Y',v_y);
			
		end	
		% Observe (i) how compact the resulting code is, and (ii) the
		% graphical representation part only takes one line. 
		%
		% Similarly, the counterpart of experiment_1002 when GFigure is
		% fully used is:
		%
		function F = experiment_2003(obj,niter)
		
			v_x = -10:0.01:10;
			v_y = v_x.^2;		
			F(1) = GFigure('m_X',v_x,'m_Y',v_y);
						
			v_x = -5:0.01:5;
			v_y = v_x.^3;
			F(2) = GFigure('m_X',v_x,'m_Y',v_y);
			
		end
		%
		%% 3. Titles and axes labels ======================================
		%
		% The following example illustrates how to add a title and label
		% the axes:
		function F = experiment_3001(obj,niter)
		
			mass = 10; 
			v_speed = 0:0.01:10;
			v_kineticEnergy = 1/2*mass*v_speed.^2;		
			ch_tit = sprintf('Mass = %g kg',mass);
			F = GFigure('m_X',v_speed,'m_Y',v_kineticEnergy,...
				'ch_xlabel','Speed [m/s]','ch_ylabel','Energy [J]',...
				'ch_title',ch_tit);
			
		end
		% The created figure now shows a title and axis labels (as long as 
		% displaySettings.b_savePlots and displaySettings.b_titleToCaption
		% in gsim.m are not simultaneously non-zero). 
		%
		% If you want to save this figure to use in a paper, you may want
		% to clear the title and, instead, showing ch_tit in the caption.
		% To this end, go to gsim.m and set the following variables as
		% follows: 		
		%
		% >>  displaySettings.b_savePlots=1;
		% >>  displaySettings.b_outputInPdf = 1;
        % >>  displaySettings.b_titleToCaption = 1;
		%
		% Now type
		%
		% >> gsim(0,3001)
		%
		% on the command line, or 
		%
		% >> gsim(1,3001)
		%
		% if you have executed this experiment before. Note that it is not
		% needed to run the experiment again to export the figure. 
		%
		% You can see that the folder TutorialFfigureExperiments_data
		% contains 
		%     1- a pdf with the figure without the title
		%     2- a txt file with text to include in the legend (you may use
		%     the latex command \input)
		%     3- a fig file, which may be required by some journals when
		%     you upload the final files after the paper is accepted. 
		%
		% To continue the tutorial, you may set displaySettings.b_savePlots
		% equal to 0 to avoid creating unnecessary files.
		%
		%% 4. Multiple curves =============================================
		% In most figures, you will be displaying multiple curves. You will
		% therefore need a legend. The following example illustrates this
		% scenario: 
		function F = experiment_4001(obj,niter)
		
			v_mass = [10 20 30]; 
			v_speed = 0:0.01:10;
			for ind_curve = length(v_mass):-1:1
				m_kineticEnergy(ind_curve,:) = 1/2*v_mass(ind_curve)*v_speed.^2;		
				c_legend{ind_curve} = sprintf('Mass = %g kg',v_mass(ind_curve));
			end
						
			F = GFigure('m_X',v_speed,'m_Y',m_kineticEnergy,...
				'ch_xlabel','Speed [m/s]','ch_ylabel','Energy [J]',...
				'c_legend',c_legend);
			
		end		
		% Observe that the property m_Y is a matrix with size
		% numberOfCurves x numberOfXAxisPoints whereas m_X is of size 1 x
		% numberOfXAxisPoints. This is because the points in all three
		% curves share the same X-coordinates. If each curve needs to use a
		% different vector of X-coordinates, one can set m_X to be of the
		% same size as m_Y, as illustrated in the following example:
		% 
		function F = experiment_4002(obj,niter)
		
			nXPoints = 100;
			
			% curve 1
			mass = 10;
			m_speed_1 = linspace(0,10,nXPoints);
			m_kineticEnergy_1 = 1/2*mass*m_speed_1.^2;
			c_legend{1} = sprintf('Mass = %g kg',mass);
			
			% curve 2
			mass = 30;
			m_speed_2 = linspace(4,12,nXPoints);
			m_kineticEnergy_2 = 1/2*mass*m_speed_2.^2;
			c_legend{2} = sprintf('Mass = %g kg',mass);
			
			% curve 3
			mass = 50;
			m_speed_3 = linspace(1,13,nXPoints);
			m_kineticEnergy_3 = 1/2*mass*m_speed_3.^2;
			c_legend{3} = sprintf('Mass = %g kg',mass);
						
			F = GFigure('m_X',[m_speed_1;m_speed_2;m_speed_3],...
				'm_Y',[m_kineticEnergy_1;m_kineticEnergy_2;m_kineticEnergy_3],...
				'ch_xlabel','Speed [m/s]','ch_ylabel','Energy [J]',...
				'c_legend',c_legend,'ch_legendPosition','NorthWest');
			
		end		
		% Note also the (optional) usage of F.ch_legendPosition to place
		% the legend in the NorthWest position. Also note that the curves
		% were plotted in colors that are easy to see and distinguish in a
		% slideshow or printed paper; this is different from the default
		% color set that MATLAB uses to plot multiple figures, as occurs
		% when GFigure is not used.  
		%
		% In experiment_4002, the number of points in the X-axis
		% is the same for all three curves. If this is not the case in your
		% simulation, you can use the function
		% GFigure.formMatrixByPaddingRows(), which essentially pads the
		% vectors of x and y values with NaN  until they have the same size
		% and can be therefore concatenated. 		
		function F = experiment_4003(obj,niter)
		
			% curve 1
			mass = 10;
			m_speed_1 = linspace(0,10,25);
			m_kineticEnergy_1 = 1/2*mass*m_speed_1.^2;
			c_legend{1} = sprintf('Mass = %g kg',mass);
			
			% curve 2
			mass = 30;
			m_speed_2 = linspace(4,12,10);
			m_kineticEnergy_2 = 1/2*mass*m_speed_2.^2;
			c_legend{2} = sprintf('Mass = %g kg',mass);
			
			% curve 3
			mass = 50;
			m_speed_3 = linspace(1,13,30);
			m_kineticEnergy_3 = 1/2*mass*m_speed_3.^2;
			c_legend{3} = sprintf('Mass = %g kg',mass);
			
			m_X = GFigure.formMatrixByPaddingRows(m_speed_1,m_speed_2,m_speed_3);
			m_Y = GFigure.formMatrixByPaddingRows(m_kineticEnergy_1,m_kineticEnergy_2,m_kineticEnergy_3);
			F = GFigure('m_X',m_X,'m_Y',m_Y,...
				'ch_xlabel','Speed [m/s]','ch_ylabel','Energy [J]',...
				'c_legend',c_legend,'ch_legendPosition','NorthWest',...
				'c_styles',{'-o','-x','-v'});
			
		end	
		%  Note that this experiment also sets the styles of the curves.
		%  The meaning of the entries of the cell array c_styles is the same
		%  as that of the plot function; type 
		%
		%  >> help plot
		% 
		%  in the command line for an explanation of the meaning of these
		%  symbols. 
		%
		%  Setting the colors of the curves is typically not necessary if
		%  one uses GFigure. Using the property colorPeriod is typically
		%  sufficient, as illustrated next:
		%
		function F = experiment_4004(obj,niter) 
			% We wish to plot the function f(x) = a*x^2 + b*x + 1 for
			% multiple pairs of values of a and b. 
			v_a = [-1 0 1];
			v_b = [-2 2];
			c_bStyles = {'-','--'}; % style for each value of b
			
			v_x = linspace(-1,1,30);
			for ind_a = 1:length(v_a)
				for ind_b = 1:length(v_b)
					ind_curve = (ind_b-1)*length(v_a) + ind_a;
					m_Y(ind_curve,:) = v_a(ind_a)*v_x.^2 + v_b(ind_b)*v_x + 1;
					c_legend{ind_curve} = sprintf('a = %g, b = %g',v_a(ind_a),v_b(ind_b));
					c_styles{ind_curve} = c_bStyles{ind_b};
				end
			end
						
			F = GFigure('m_X',v_x,'m_Y',m_Y,...
				'ch_xlabel','x','ch_ylabel','f(x)',...
				'c_legend',c_legend,'ch_legendPosition','NorthWest',...
				'colorPeriod',length(v_a),...
				'c_styles',c_styles);	
		end	
		% Note that in experiment_4004, each value of <a> corresponds to a
		% color whereas each value of <b> corresponds to a line style. This
		% approach is desirable in papers and presentations since it
		% facilitates understanding the figure.
		%
		%% 5. Subplots and sequences ======================================
		% Sometimes, different curves need to be displayed in different
		% axes. To this end, one can create an GFigure whose property
		% m_multiplot is an M x N matrix of GFigure objects which
		% correspond to each axis. An M x N multiplot will be created
		% accordingly. The following example goes along the lines of
		% experiment_4004. 
		function F = experiment_5001(obj,niter)		
			% We wish to plot the function f(x) = a*x^2 + b*x + 1 for
			% multiple pairs of values of a and b. 
			v_a = [-1 0 1];
			v_b = [-2 2];
			
			v_x = linspace(-1,1,30);
			for ind_a = 1:length(v_a)
				for ind_b = 1:length(v_b)
					v_y= v_a(ind_a)*v_x.^2 + v_b(ind_b)*v_x + 1;					
					m_multiplot(ind_a,ind_b) = GFigure('m_X',v_x,'m_Y',v_y,...
						'ch_xlabel','x','ch_ylabel','f(x)',...	
						'ch_title',sprintf('a = %g, b = %g',v_a(ind_a),v_b(ind_b)));
				end
			end
			
			F = GFigure('m_multiplot',m_multiplot);	
		end	
		% 
		% If you are trying to find the right value for your parameters in
		% a simulation, you may run the simulation for a large number of
		% values and then plot the figures sequentially after the
		% simulation has finished for all parameters.  
		%
		% This can be done in the same way as a subplot, but you must set
		% the property ch_multiplotType to 'sequence' as illustrated below:
		function F = experiment_5002(obj,niter)		
			% We wish to plot the function f(x) = a*x^2 + b*x + 1 for
			% multiple pairs of values of a and b. 
			v_a = [-1 0 1];
			v_b = [-2 2];
			
			v_x = linspace(-1,1,30);
			for ind_a = 1:length(v_a)
				for ind_b = 1:length(v_b)
					v_y= v_a(ind_a)*v_x.^2 + v_b(ind_b)*v_x + 1;					
					m_multiplot(ind_a,ind_b) = GFigure('m_X',v_x,'m_Y',v_y,...
						'ch_xlabel','x','ch_ylabel','f(x)',...	
						'ch_title',sprintf('a = %g, b = %g',v_a(ind_a),v_b(ind_b)));
				end
			end
			
			F = GFigure('m_multiplot',m_multiplot,'ch_multiplotType','sequence');	
		end	
		%
		%% 6. 3D plots ====================================================
		%
		% The following example illustrates how to draw 3D plots. Note that
		% the meaning of m_X and m_Y is different from before. 
		function F = experiment_6001(obj,niter)		
			v_x = linspace(-1,1,20);
			v_y = linspace(-1,1,20);
			
			for ind_x = 1:length(v_x)
				for ind_y = 1:length(v_y)
					m_X(ind_x,ind_y) = v_x(ind_x);
					m_Y(ind_x,ind_y) = v_y(ind_y);
					m_Z(ind_x,ind_y) = v_x(ind_x)^2 + v_y(ind_y)^2;
				end
			end
			
			F = GFigure('m_X',m_X,'m_Y',m_Y,'m_Z',m_Z,'ch_plotType3D','surf',...
				'ch_xlabel','x','ch_ylabel','y','ch_zlabel','f(x,y)=x^2+y^2');
		end
		%
		%
		%% 7. Fixing issues without running experiments again =============
		% Suppose that we run a simulation that took long time; e.g. days.
		% When it finished, it stored the resulting GFigure. Now we want
		% to tune how such a figure displays without re-running the
		% experiment. 
		%
		% A simple approach is to create another experiment which simply
		% loads the output of the simulation of interest and modifies it.
		% For example, the next experiment loads and modifies the output of
		% experiment 4003 to adjust the limits of the x-axis. It is
		% necessary that you have run experiment 4003 at least once before
		% proceeding. 
		% 
		function F = experiment_7001(obj,niter)					
			F = obj.loadGFigure(4003);		
			F.v_xlim = [4 10]; 
		end
		%
		% Another common situation is when we change the notation at some
		% point in the writing process of a paper. Rewriting our code and
		% re-running all experiments would be too time consuming and
		% error prone. GFigure provides an easy and quick fix through
		% translation tables: 
		function F = experiment_7002(obj,niter)					
			F = obj.loadGFigure(4003);		
			F.v_xlim = [4 10]; 
			F.c_localTranslationTable = {'Energy','E';'Speed','v';'Mass','m'};
		end
		% 
		% The previous example describes a local translation table, which
		% determines how an GFigure is displayed. Note that a translation
		% table does not modify the fields ch_title, c_legend, and so on;
		% it just modifies how they display. 
		%
		% However, in a simulation study we typically have tens of
		% experiments, and applying the procedure in experiment_7002, which
		% relies on *local* translation tables may be inconvenient. In
		% those cases, it is more convenient to apply the *global*
		% translation table, which applies to all figures that are to be
		% displayed. 
		%
		% The global translation table is set in gsim.m. For an example,
		% replace the line
		%
		% >> displaySettings.c_globalTranslationTable = {}; 
		%
		% in gsim.m with
		%
		% >> displaySettings.c_globalTranslationTable = {'Energy','ENERGY';'Mass','MASS';'Speed','SPEED'}; 
		%
		% and run experiment 4003 again. 
		%
		% Note that the local table is applied first, whereas the global
		% table is applied afterwards. To see this, use the following table
		%
		% >> displaySettings.c_globalTranslationTable = {'E','e';'m','M'}; 
		%
		% and run experiment 7002 again. 
		%
		%% 8. Conclusion ==================================================
		% The usage of GFigure described in this tutorial covers the great
		% majority of situations that we typically find ourselves in when
		% conducting a MATLAB simulation study. For further features of
		% GFigure, please see GFigure.m.
		%
		% If you find any bug or have any issue, please drop a line to 
		% daniel.romero@uia.no.
		%
		% Good luck!!
		
	end
	
end
